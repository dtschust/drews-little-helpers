#!/usr/bin/env node
/* eslint-disable camelcase */

require('isomorphic-fetch');
require('dotenv').config();
const mongoose = require('mongoose');
const FeedHiatus = require('../src/mongoose-models/Feed-Hiatus');

const feedWranglerToken = process.env.FEED_WRANGLER_ACCESS_TOKEN;
const { getDrewsHelpfulRobot } = require('../src/utils/slack');

const { sendMessageToFollowShows, sendBlockMessageToFollowShows } = getDrewsHelpfulRobot();

mongoose.connect(process.env.MONGO_DB_URI, {
	useNewUrlParser: true,
	useUnifiedTopology: true,
});

const now = Date.now();

function subscribeToFeed({ feed_url, title, site_url } = {}) {
	return fetch(
		`https://feedwrangler.net/api/v2/subscriptions/add_feed?access_token=${feedWranglerToken}&feed_url=${encodeURIComponent(
			feed_url
		)}`
	)
		.then((response) => response.json())
		.then(async ({ error, result }) => {
			if (error || result !== 'success') {
				console.error(`Error subscribing to ${title}, error: ${error}, result: ${result}`);
				return sendMessageToFollowShows(
					`Error subscribing to ${title}, error: ${error}, result: ${result}`
				);
			}
			console.log(`Successfully resubscribed to ${title} (${site_url})`);
			return sendMessageToFollowShows(
				`Back from hiatus! Resubscribed to ${title} (${site_url})`
			);
		});
}

async function warnAboutPendingRestores() {
	const feedsToRestoreSoon = await FeedHiatus.find({
		end_time: { $lte: now + 86400000, $gte: now },
	});
	if (!feedsToRestoreSoon.length) {
		return true;
	}

	let blocks = [
		{
			type: 'section',
			text: {
				type: 'mrkdwn',
				text: 'The following feeds are going to be restored from hiatus in the next 24 hours:',
			},
		},
	];
	blocks = blocks.concat(
		feedsToRestoreSoon.map(({ site_url, title, feed_id, end_time }) => {
			return {
				type: 'section',
				text: {
					type: 'mrkdwn',
					text: `<${site_url}|${title}>`,
				},
				accessory: {
					type: 'overflow',
					// TODO: An unsubscribe option, with a confirmation for unsubscribing
					options: [1, 2, 4, 8].map((weeksToSnooze) => {
						const newEndTime = end_time + weeksToSnooze * 604800000;
						return {
							text: {
								type: 'plain_text',
								text: `Snooze ${weeksToSnooze} weeks`,
							},
							value: `Snooze ${weeksToSnooze} weeks`,
							url: `${
								process.env.SERVER_URL
							}/snooze-hiatus?feed_id=${feed_id}&end_time=${newEndTime}&title=${encodeURIComponent(
								title
							)}`,
						};
					}),
				},
			};
		})
	);
	return sendBlockMessageToFollowShows(blocks);
}

async function main() {
	// This will find and restore all hiatus feeds
	// const feedsToRestore = await FeedHiatus.find();
	await warnAboutPendingRestores();

	const feedsToRestore = await FeedHiatus.find({ end_time: { $lte: now } });

	if (!feedsToRestore.length) {
		console.log('No feeds to restore from hiatus');
	}

	await Promise.all(
		feedsToRestore.map(async (feed) => {
			await subscribeToFeed(feed);
			// TODO: Maybe mark all as read??
			await feed.remove();
		})
	);
}

main().then(process.exit);
