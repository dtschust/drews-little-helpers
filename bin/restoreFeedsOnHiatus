#!/usr/bin/env node
/* eslint-disable camelcase */

require('isomorphic-fetch');
require('dotenv').config();
const FeedHiatus = require('../src/mongoose-models/Feed-Hiatus');
require('../src/utils/mongoose-connect');

const feedWranglerToken = process.env.FEED_WRANGLER_ACCESS_TOKEN;
const { getDrewsHelpfulRobot } = require('../src/utils/slack');

const { sendMessageToFollowShows } = getDrewsHelpfulRobot();

const now = Date.now();

function subscribeToFeed({ feed_url, title, site_url } = {}) {
	return fetch(
		`https://feedwrangler.net/api/v2/subscriptions/add_feed?access_token=${feedWranglerToken}&feed_url=${encodeURIComponent(
			feed_url
		)}`
	)
		.then((response) => response.json())
		.then(async ({ error, result }) => {
			if (error || result !== 'success') {
				console.error(`Error subscribing to ${title}, error: ${error}, result: ${result}`);
				return sendMessageToFollowShows(
					`Error subscribing to ${title}, error: ${error}, result: ${result}`
				);
			}
			console.log(`Successfully resubscribed to ${title} (${site_url})`);
			return sendMessageToFollowShows(
				`Back from hiatus! Resubscribed to ${title} (${site_url})`
			);
		});
}

async function warnAboutPendingRestores() {
	const feedsToRestoreSoon = await FeedHiatus.find({
		end_time: { $lte: now + 86400000, $gte: now },
	});
	if (!feedsToRestoreSoon.length) {
		return true;
	}
	await sendMessageToFollowShows(
		'The following feeds are going to be restored from hiatus in the next 24 hours:'
	);

	// eslint-disable-next-line no-restricted-syntax
	for (const feedToRestoreSoon of feedsToRestoreSoon) {
		const { site_url, title, feed_id, end_time } = feedToRestoreSoon;

		const attachment = {
			fallback: 'TODO',
			callback_Id: `${feed_id}_${end_time}`,
			actions: [1, 2, 4, 8].map((weeksToSnooze) => {
				const newEndTime = end_time + weeksToSnooze * 604800000;
				return {
					name: `snoozeFeed ${feed_id} ${weeksToSnooze}`,
					text: `Snooze ${weeksToSnooze} weeks`,
					type: 'button',
					value: JSON.stringify({
						feed_id,
						end_time: newEndTime,
						title: encodeURIComponent(title),
					}),
				};
			}),
			// TODO: Unsubscribe button
		};
		// eslint-disable-next-line no-await-in-loop
		await sendMessageToFollowShows(`<${site_url}|${title}>`, {
			attachments: [attachment],
		});
	}

	return true;
}

async function main() {
	// This will find and restore all hiatus feeds
	// const feedsToRestore = await FeedHiatus.find();
	await warnAboutPendingRestores();

	const feedsToRestore = await FeedHiatus.find({ end_time: { $lte: now } });

	if (!feedsToRestore.length) {
		console.log('No feeds to restore from hiatus');
	}

	await Promise.all(
		feedsToRestore.map(async (feed) => {
			await subscribeToFeed(feed);
			// TODO: Maybe mark all as read??
			await feed.remove();
		})
	);
}

main().then(process.exit);
