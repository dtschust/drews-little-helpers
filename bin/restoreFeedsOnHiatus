#!/usr/bin/env node
/* eslint-disable camelcase */

require('isomorphic-fetch');
require('dotenv').config();
const FeedHiatus = require('../src/mongoose-models/Feed-Hiatus');
require('../src/utils/mongoose-connect');

const feedWranglerToken = process.env.FEED_WRANGLER_ACCESS_TOKEN;
const { getDrewsHelpfulRobot } = require('../src/utils/slack');

const { sendMessageToFollowShows } = getDrewsHelpfulRobot();

const now = Date.now();

function subscribeToFeed({ feed_url, title, site_url } = {}) {
	return fetch(
		`https://feedwrangler.net/api/v2/subscriptions/add_feed?access_token=${feedWranglerToken}&feed_url=${encodeURIComponent(
			feed_url
		)}`
	)
		.then((response) => response.json())
		.then(async ({ error, result }) => {
			if (error || result !== 'success') {
				console.error(`Error subscribing to ${title}, error: ${error}, result: ${result}`);
				return sendMessageToFollowShows(
					`Error subscribing to ${title}, error: ${error}, result: ${result}`
				);
			}
			console.log(`Successfully resubscribed to ${title} (${site_url})`);
			return sendMessageToFollowShows(
				`Back from hiatus! Resubscribed to ${title} (${site_url})`
			);
		});
}

async function warnAboutPendingRestores() {
	const feedsToRestoreSoon = await FeedHiatus.find({
		end_time: { $lte: now + 86400000, $gte: now },
	});
	if (!feedsToRestoreSoon.length) {
		return true;
	}
	await sendMessageToFollowShows(
		'The following feeds are going to be restored from hiatus in the next 24 hours:'
	);

	// eslint-disable-next-line no-restricted-syntax
	for (const feedToRestoreSoon of feedsToRestoreSoon) {
		const { title, feed_id, end_time, site_url } = feedToRestoreSoon;

		const attachment = {
			fallback: 'TODO',
			callback_id: `${feed_id}_${end_time}`,
			actions: [1, 4, 8]
				.map((weeksToSnooze) => {
					const newEndTime = end_time + weeksToSnooze * 604800000;
					return {
						name: `snoozeFeed ${feed_id} ${weeksToSnooze}`,
						text: `Snooze ${weeksToSnooze} weeks`,
						type: 'button',
						value: JSON.stringify({
							feed_id,
							end_time: newEndTime,
							title: encodeURIComponent(title),
						}),
					};
				})
				.concat([
					{
						name: `unsubscribeFeed ${feed_id}`,
						text: `Unsubscribe Permanently`,
						type: 'button',
						style: 'danger',
						value: JSON.stringify({
							feed_id,
							title: encodeURIComponent(title),
						}),
					},
					{
						name: `dismiss ${feed_id}`,
						text: `OK`,
						type: 'button',
						style: 'primary',
						value: feed_id,
					},
				]),
		};
		// eslint-disable-next-line no-await-in-loop
		await sendMessageToFollowShows(`*${title}* \`(${site_url})\``, {
			attachments: [attachment],
		});
	}

	return true;
}

async function main() {
	await warnAboutPendingRestores();

	// This will find and restore all hiatus feeds
	// const feedsToRestore = await FeedHiatus.find();
	const feedsToRestore = await FeedHiatus.find({ end_time: { $lte: now } });

	if (!feedsToRestore.length) {
		console.log('No feeds to restore from hiatus');
	}

	await Promise.all(
		feedsToRestore.map(async (feed) => {
			await subscribeToFeed(feed);
			// TODO: Maybe mark all as read??
			await feed.remove();
		})
	);
}

main().then(process.exit);
