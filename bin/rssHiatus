#!/usr/bin/env node
/* eslint-disable camelcase */

require('isomorphic-fetch');
require('dotenv').config();
const _ = require('lodash');
const mongoose = require('mongoose');
const inquirer = require('inquirer');
const { getDrewsHelpfulRobot } = require('../src/utils/slack');

const { sendMessageToFollowShows } = getDrewsHelpfulRobot();

const FeedHiatus = require('../src/mongoose-models/Feed-Hiatus');

const feedWranglerToken = process.env.FEED_WRANGLER_ACCESS_TOKEN;

mongoose.connect(process.env.MONGO_DB_URI, {
	useNewUrlParser: true,
	useUnifiedTopology: true,
});

function unsubscribeToFeed({ feed_id, title, site_url, weeks, end_time } = {}) {
	return fetch(
		`https://feedwrangler.net/api/v2/subscriptions/remove_feed?access_token=${feedWranglerToken}&feed_id=${feed_id}`
	)
		.then((response) => response.json())
		.then(async ({ error, result }) => {
			if (error || result !== 'success') {
				console.error(
					`Error unsubscribing to ${title}, error: ${error}, result: ${result}`
				);
				return sendMessageToFollowShows(
					`Error unsubscribing to ${title}, error: ${error}, result: ${result}`
				);
			}
			console.log(
				`On Hiatus! Unsubscribed to ${title} (${site_url}) for ${weeks} weeks. Will be back on ${new Date(
					end_time
				).toLocaleDateString('en-US')}`
			);
			return sendMessageToFollowShows(
				`On Hiatus! Unsubscribed to ${title} (${site_url}) for ${weeks} weeks. Will be back on ${new Date(
					end_time
				).toLocaleDateString('en-US')}`
			);
		});
}

async function getAllUnreads(offset = 0) {
	const limit = 100;
	return fetch(
		`https://feedwrangler.net/api/v2/feed_items/list?read=false&offset=${offset}&limit=${limit}&access_token=${feedWranglerToken}`
	)
		.then((response) => response.json())
		.then(async ({ feed_items: feedItems }) => {
			if (feedItems.length === limit) {
				const newOffset = offset + limit;
				const moreFeedItems = await getAllUnreads(newOffset);
				return feedItems.concat(moreFeedItems);
			}
			return feedItems;
		});
}

async function getAllUnreadsByFeed() {
	const allUnreads = await getAllUnreads();
	/* eslint-disable no-param-reassign */
	return allUnreads.reduce((map, feedItem) => {
		map[feedItem.feed_id] = map[feedItem.feed_id] || [];
		map[feedItem.feed_id].push(feedItem);
		return map;
		/* eslint-enable no-param-reassign */
	}, {});
}

async function main() {
	console.log('Fetching feeds and unread counts...');
	const allUnreadsByFeed = await getAllUnreadsByFeed();
	const { feeds } = await fetch(
		`https://feedwrangler.net/api/v2/subscriptions/list?access_token=${feedWranglerToken}`
	).then((response) => response.json());

	await inquirer
		.prompt([
			{
				type: 'checkbox',
				name: 'feedsToHiatus',
				message: 'Which feeds would you like to put on a hiatus?',
				loop: false,
				pageSize: 30,
				choices: _.sortBy(
					feeds.map(({ title, feed_id, site_url, feed_url }) => {
						const unreads = allUnreadsByFeed[feed_id] || [];
						const unreadsCount = unreads.length;
						return {
							name: `${
								unreadsCount ? `(${unreadsCount})` : ''
							} ${title} (${site_url})`,
							value: { title, feed_id, feed_url, site_url },
							title,
						};
					}),
					'title'
				),
			},
			{
				type: 'number',
				name: 'weeks',
				message: 'How many weeks would you like to put these on hiatus for?',
				default: 1,
			},
		])
		.then(async ({ feedsToHiatus, weeks }) => {
			if (!feedsToHiatus.length) {
				return Promise.resolve();
			}

			// TODO: Ensure that none of these feeds have unreads
			const feedsToHiatusWithUnreads = feedsToHiatus.filter((feed) => {
				const unreads = allUnreadsByFeed[feed.feed_id] || [];
				const unreadsCount = unreads.length;
				return unreadsCount > 0;
			});

			if (feedsToHiatusWithUnreads.length) {
				// TODO: Make these options a TS enum
				const { dealWithUnreads } = await inquirer.prompt([
					{
						type: 'list',
						name: 'dealWithUnreads',
						message:
							'You have selected some feeds to hiatus that have unreads currently. What would you like to do?',
						choices: [
							{
								name: 'Hiatus them anyway, knowing that I may lose these unreads',
								value: 'yes',
							},
							{
								name: 'Do not hiatus these, just hiatus the other ones',
								value: 'no',
							},
							{
								name: 'Bookmark all the unreads to pinboard (make sure pinboard is not in the list, THEN hiatus the feeds',
								value: 'pinboard',
							},
						],
					},
				]);
				if (dealWithUnreads === 'no') {
					// eslint-disable-next-line no-param-reassign
					feedsToHiatus = feedsToHiatus.filter((feed) => {
						const unreads = allUnreadsByFeed[feed.feed_id] || [];
						const unreadsCount = unreads.length;
						return unreadsCount === 0;
					});
				} else if (dealWithUnreads === 'pinboard') {
					// TODO: implement
					console.log('Pinboard path not implemented, sorry!');
					process.exit(1);
				}
			}

			console.log(feedsToHiatus);
			const end_time = Date.now() + weeks * 604800000;
			// TODO: Hit an API endpoint that executes all the code below. That way I can
			// move this to in-app
			return Promise.all(
				feedsToHiatus.map(async ({ feed_id, title, feed_url, site_url }) => {
					const feedHiatus = new FeedHiatus({
						feed_id,
						title,
						feed_url,
						site_url,
						end_time,
					});
					await feedHiatus.save();

					await unsubscribeToFeed({ feed_id, title, site_url, weeks, end_time });
				})
			);
		});
}

main().then(process.exit);
